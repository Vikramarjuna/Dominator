// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.0
// - protoc             v3.12.4
// source: hypervisor/grpc/hypervisor.proto

package hypervisor_grpc

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	Hypervisor_GetVmInfo_FullMethodName          = "/hypervisor.Hypervisor/GetVmInfo"
	Hypervisor_GetVmInfos_FullMethodName         = "/hypervisor.Hypervisor/GetVmInfos"
	Hypervisor_ListVMs_FullMethodName            = "/hypervisor.Hypervisor/ListVMs"
	Hypervisor_CreateVm_FullMethodName           = "/hypervisor.Hypervisor/CreateVm"
	Hypervisor_CreateVmAsync_FullMethodName      = "/hypervisor.Hypervisor/CreateVmAsync"
	Hypervisor_StartVm_FullMethodName            = "/hypervisor.Hypervisor/StartVm"
	Hypervisor_StartVmAsync_FullMethodName       = "/hypervisor.Hypervisor/StartVmAsync"
	Hypervisor_StopVm_FullMethodName             = "/hypervisor.Hypervisor/StopVm"
	Hypervisor_RebootVm_FullMethodName           = "/hypervisor.Hypervisor/RebootVm"
	Hypervisor_DestroyVm_FullMethodName          = "/hypervisor.Hypervisor/DestroyVm"
	Hypervisor_DestroyVmAsync_FullMethodName     = "/hypervisor.Hypervisor/DestroyVmAsync"
	Hypervisor_ListSubnets_FullMethodName        = "/hypervisor.Hypervisor/ListSubnets"
	Hypervisor_GetUpdates_FullMethodName         = "/hypervisor.Hypervisor/GetUpdates"
	Hypervisor_ChangeVmTags_FullMethodName       = "/hypervisor.Hypervisor/ChangeVmTags"
	Hypervisor_ChangeVmOwnerUsers_FullMethodName = "/hypervisor.Hypervisor/ChangeVmOwnerUsers"
	Hypervisor_ChangeVmSize_FullMethodName       = "/hypervisor.Hypervisor/ChangeVmSize"
	Hypervisor_GetCapacity_FullMethodName        = "/hypervisor.Hypervisor/GetCapacity"
)

// HypervisorClient is the client API for Hypervisor service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Hypervisor service - manages virtual machines on a hypervisor host.
type HypervisorClient interface {
	// VM Information
	GetVmInfo(ctx context.Context, in *GetVmInfoRequest, opts ...grpc.CallOption) (*GetVmInfoResponse, error)
	GetVmInfos(ctx context.Context, in *GetVmInfosRequest, opts ...grpc.CallOption) (*GetVmInfosResponse, error)
	ListVMs(ctx context.Context, in *ListVMsRequest, opts ...grpc.CallOption) (*ListVMsResponse, error)
	// VM Lifecycle
	// CreateVm - Bidirectional streaming for ImageDataSize mode
	// Client streams: metadata + image data + user data + secondary volumes
	// Server streams: progress updates, then final response
	// Supports all modes: ImageName, ImageURL, and ImageDataSize
	// TODO: Not yet implemented - returns Unimplemented error
	CreateVm(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[CreateVmRequest, CreateVmResponse], error)
	// CreateVmAsync - Asynchronous/non-blocking (AWS EC2 pattern)
	// Returns immediately with VM in StateStarting or StateStopped (if DoNotStart=true)
	// Supports ImageName and ImageURL modes only (no ImageDataSize streaming)
	//
	// Design Note: We use separate APIs for different use cases:
	// - CreateVmAsync: Simple async for ImageName/ImageURL (90% of use cases)
	// - CreateVm: Bidirectional streaming for ImageDataSize (rare custom image uploads)
	// This keeps APIs clean and purpose-specific rather than one complex API.
	CreateVmAsync(ctx context.Context, in *CreateVmAsyncRequest, opts ...grpc.CallOption) (*CreateVmAsyncResponse, error)
	// StartVm - Synchronous/blocking (SRPC-compatible)
	// Blocks until VM starts and DHCP completes (or times out)
	StartVm(ctx context.Context, in *StartVmRequest, opts ...grpc.CallOption) (*StartVmResponse, error)
	// StartVmAsync - Asynchronous/non-blocking (AWS EC2 pattern)
	// Returns immediately with VM in StateStarting
	StartVmAsync(ctx context.Context, in *StartVmAsyncRequest, opts ...grpc.CallOption) (*StartVmAsyncResponse, error)
	StopVm(ctx context.Context, in *StopVmRequest, opts ...grpc.CallOption) (*StopVmResponse, error)
	RebootVm(ctx context.Context, in *RebootVmRequest, opts ...grpc.CallOption) (*RebootVmResponse, error)
	// DestroyVm - Synchronous/blocking (SRPC-compatible)
	// Blocks until VM is fully destroyed and files are deleted
	DestroyVm(ctx context.Context, in *DestroyVmRequest, opts ...grpc.CallOption) (*DestroyVmResponse, error)
	// DestroyVmAsync - Asynchronous/non-blocking (AWS EC2 pattern)
	// Returns immediately with VM in StateDestroying
	DestroyVmAsync(ctx context.Context, in *DestroyVmAsyncRequest, opts ...grpc.CallOption) (*DestroyVmAsyncResponse, error)
	// Subnet Management
	ListSubnets(ctx context.Context, in *ListSubnetsRequest, opts ...grpc.CallOption) (*ListSubnetsResponse, error)
	// Real-time Updates (watch pattern)
	GetUpdates(ctx context.Context, in *GetUpdatesRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Update], error)
	// VM Configuration Changes
	ChangeVmTags(ctx context.Context, in *ChangeVmTagsRequest, opts ...grpc.CallOption) (*ChangeVmTagsResponse, error)
	ChangeVmOwnerUsers(ctx context.Context, in *ChangeVmOwnerUsersRequest, opts ...grpc.CallOption) (*ChangeVmOwnerUsersResponse, error)
	ChangeVmSize(ctx context.Context, in *ChangeVmSizeRequest, opts ...grpc.CallOption) (*ChangeVmSizeResponse, error)
	// Capacity and Status
	GetCapacity(ctx context.Context, in *GetCapacityRequest, opts ...grpc.CallOption) (*GetCapacityResponse, error)
}

type hypervisorClient struct {
	cc grpc.ClientConnInterface
}

func NewHypervisorClient(cc grpc.ClientConnInterface) HypervisorClient {
	return &hypervisorClient{cc}
}

func (c *hypervisorClient) GetVmInfo(ctx context.Context, in *GetVmInfoRequest, opts ...grpc.CallOption) (*GetVmInfoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetVmInfoResponse)
	err := c.cc.Invoke(ctx, Hypervisor_GetVmInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hypervisorClient) GetVmInfos(ctx context.Context, in *GetVmInfosRequest, opts ...grpc.CallOption) (*GetVmInfosResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetVmInfosResponse)
	err := c.cc.Invoke(ctx, Hypervisor_GetVmInfos_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hypervisorClient) ListVMs(ctx context.Context, in *ListVMsRequest, opts ...grpc.CallOption) (*ListVMsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListVMsResponse)
	err := c.cc.Invoke(ctx, Hypervisor_ListVMs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hypervisorClient) CreateVm(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[CreateVmRequest, CreateVmResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Hypervisor_ServiceDesc.Streams[0], Hypervisor_CreateVm_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[CreateVmRequest, CreateVmResponse]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Hypervisor_CreateVmClient = grpc.BidiStreamingClient[CreateVmRequest, CreateVmResponse]

func (c *hypervisorClient) CreateVmAsync(ctx context.Context, in *CreateVmAsyncRequest, opts ...grpc.CallOption) (*CreateVmAsyncResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateVmAsyncResponse)
	err := c.cc.Invoke(ctx, Hypervisor_CreateVmAsync_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hypervisorClient) StartVm(ctx context.Context, in *StartVmRequest, opts ...grpc.CallOption) (*StartVmResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StartVmResponse)
	err := c.cc.Invoke(ctx, Hypervisor_StartVm_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hypervisorClient) StartVmAsync(ctx context.Context, in *StartVmAsyncRequest, opts ...grpc.CallOption) (*StartVmAsyncResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StartVmAsyncResponse)
	err := c.cc.Invoke(ctx, Hypervisor_StartVmAsync_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hypervisorClient) StopVm(ctx context.Context, in *StopVmRequest, opts ...grpc.CallOption) (*StopVmResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StopVmResponse)
	err := c.cc.Invoke(ctx, Hypervisor_StopVm_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hypervisorClient) RebootVm(ctx context.Context, in *RebootVmRequest, opts ...grpc.CallOption) (*RebootVmResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RebootVmResponse)
	err := c.cc.Invoke(ctx, Hypervisor_RebootVm_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hypervisorClient) DestroyVm(ctx context.Context, in *DestroyVmRequest, opts ...grpc.CallOption) (*DestroyVmResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DestroyVmResponse)
	err := c.cc.Invoke(ctx, Hypervisor_DestroyVm_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hypervisorClient) DestroyVmAsync(ctx context.Context, in *DestroyVmAsyncRequest, opts ...grpc.CallOption) (*DestroyVmAsyncResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DestroyVmAsyncResponse)
	err := c.cc.Invoke(ctx, Hypervisor_DestroyVmAsync_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hypervisorClient) ListSubnets(ctx context.Context, in *ListSubnetsRequest, opts ...grpc.CallOption) (*ListSubnetsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListSubnetsResponse)
	err := c.cc.Invoke(ctx, Hypervisor_ListSubnets_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hypervisorClient) GetUpdates(ctx context.Context, in *GetUpdatesRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[Update], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &Hypervisor_ServiceDesc.Streams[1], Hypervisor_GetUpdates_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[GetUpdatesRequest, Update]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Hypervisor_GetUpdatesClient = grpc.ServerStreamingClient[Update]

func (c *hypervisorClient) ChangeVmTags(ctx context.Context, in *ChangeVmTagsRequest, opts ...grpc.CallOption) (*ChangeVmTagsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ChangeVmTagsResponse)
	err := c.cc.Invoke(ctx, Hypervisor_ChangeVmTags_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hypervisorClient) ChangeVmOwnerUsers(ctx context.Context, in *ChangeVmOwnerUsersRequest, opts ...grpc.CallOption) (*ChangeVmOwnerUsersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ChangeVmOwnerUsersResponse)
	err := c.cc.Invoke(ctx, Hypervisor_ChangeVmOwnerUsers_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hypervisorClient) ChangeVmSize(ctx context.Context, in *ChangeVmSizeRequest, opts ...grpc.CallOption) (*ChangeVmSizeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ChangeVmSizeResponse)
	err := c.cc.Invoke(ctx, Hypervisor_ChangeVmSize_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hypervisorClient) GetCapacity(ctx context.Context, in *GetCapacityRequest, opts ...grpc.CallOption) (*GetCapacityResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetCapacityResponse)
	err := c.cc.Invoke(ctx, Hypervisor_GetCapacity_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// HypervisorServer is the server API for Hypervisor service.
// All implementations should embed UnimplementedHypervisorServer
// for forward compatibility.
//
// Hypervisor service - manages virtual machines on a hypervisor host.
type HypervisorServer interface {
	// VM Information
	GetVmInfo(context.Context, *GetVmInfoRequest) (*GetVmInfoResponse, error)
	GetVmInfos(context.Context, *GetVmInfosRequest) (*GetVmInfosResponse, error)
	ListVMs(context.Context, *ListVMsRequest) (*ListVMsResponse, error)
	// VM Lifecycle
	// CreateVm - Bidirectional streaming for ImageDataSize mode
	// Client streams: metadata + image data + user data + secondary volumes
	// Server streams: progress updates, then final response
	// Supports all modes: ImageName, ImageURL, and ImageDataSize
	// TODO: Not yet implemented - returns Unimplemented error
	CreateVm(grpc.BidiStreamingServer[CreateVmRequest, CreateVmResponse]) error
	// CreateVmAsync - Asynchronous/non-blocking (AWS EC2 pattern)
	// Returns immediately with VM in StateStarting or StateStopped (if DoNotStart=true)
	// Supports ImageName and ImageURL modes only (no ImageDataSize streaming)
	//
	// Design Note: We use separate APIs for different use cases:
	// - CreateVmAsync: Simple async for ImageName/ImageURL (90% of use cases)
	// - CreateVm: Bidirectional streaming for ImageDataSize (rare custom image uploads)
	// This keeps APIs clean and purpose-specific rather than one complex API.
	CreateVmAsync(context.Context, *CreateVmAsyncRequest) (*CreateVmAsyncResponse, error)
	// StartVm - Synchronous/blocking (SRPC-compatible)
	// Blocks until VM starts and DHCP completes (or times out)
	StartVm(context.Context, *StartVmRequest) (*StartVmResponse, error)
	// StartVmAsync - Asynchronous/non-blocking (AWS EC2 pattern)
	// Returns immediately with VM in StateStarting
	StartVmAsync(context.Context, *StartVmAsyncRequest) (*StartVmAsyncResponse, error)
	StopVm(context.Context, *StopVmRequest) (*StopVmResponse, error)
	RebootVm(context.Context, *RebootVmRequest) (*RebootVmResponse, error)
	// DestroyVm - Synchronous/blocking (SRPC-compatible)
	// Blocks until VM is fully destroyed and files are deleted
	DestroyVm(context.Context, *DestroyVmRequest) (*DestroyVmResponse, error)
	// DestroyVmAsync - Asynchronous/non-blocking (AWS EC2 pattern)
	// Returns immediately with VM in StateDestroying
	DestroyVmAsync(context.Context, *DestroyVmAsyncRequest) (*DestroyVmAsyncResponse, error)
	// Subnet Management
	ListSubnets(context.Context, *ListSubnetsRequest) (*ListSubnetsResponse, error)
	// Real-time Updates (watch pattern)
	GetUpdates(*GetUpdatesRequest, grpc.ServerStreamingServer[Update]) error
	// VM Configuration Changes
	ChangeVmTags(context.Context, *ChangeVmTagsRequest) (*ChangeVmTagsResponse, error)
	ChangeVmOwnerUsers(context.Context, *ChangeVmOwnerUsersRequest) (*ChangeVmOwnerUsersResponse, error)
	ChangeVmSize(context.Context, *ChangeVmSizeRequest) (*ChangeVmSizeResponse, error)
	// Capacity and Status
	GetCapacity(context.Context, *GetCapacityRequest) (*GetCapacityResponse, error)
}

// UnimplementedHypervisorServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedHypervisorServer struct{}

func (UnimplementedHypervisorServer) GetVmInfo(context.Context, *GetVmInfoRequest) (*GetVmInfoResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetVmInfo not implemented")
}
func (UnimplementedHypervisorServer) GetVmInfos(context.Context, *GetVmInfosRequest) (*GetVmInfosResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetVmInfos not implemented")
}
func (UnimplementedHypervisorServer) ListVMs(context.Context, *ListVMsRequest) (*ListVMsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListVMs not implemented")
}
func (UnimplementedHypervisorServer) CreateVm(grpc.BidiStreamingServer[CreateVmRequest, CreateVmResponse]) error {
	return status.Error(codes.Unimplemented, "method CreateVm not implemented")
}
func (UnimplementedHypervisorServer) CreateVmAsync(context.Context, *CreateVmAsyncRequest) (*CreateVmAsyncResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateVmAsync not implemented")
}
func (UnimplementedHypervisorServer) StartVm(context.Context, *StartVmRequest) (*StartVmResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method StartVm not implemented")
}
func (UnimplementedHypervisorServer) StartVmAsync(context.Context, *StartVmAsyncRequest) (*StartVmAsyncResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method StartVmAsync not implemented")
}
func (UnimplementedHypervisorServer) StopVm(context.Context, *StopVmRequest) (*StopVmResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method StopVm not implemented")
}
func (UnimplementedHypervisorServer) RebootVm(context.Context, *RebootVmRequest) (*RebootVmResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RebootVm not implemented")
}
func (UnimplementedHypervisorServer) DestroyVm(context.Context, *DestroyVmRequest) (*DestroyVmResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DestroyVm not implemented")
}
func (UnimplementedHypervisorServer) DestroyVmAsync(context.Context, *DestroyVmAsyncRequest) (*DestroyVmAsyncResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DestroyVmAsync not implemented")
}
func (UnimplementedHypervisorServer) ListSubnets(context.Context, *ListSubnetsRequest) (*ListSubnetsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListSubnets not implemented")
}
func (UnimplementedHypervisorServer) GetUpdates(*GetUpdatesRequest, grpc.ServerStreamingServer[Update]) error {
	return status.Error(codes.Unimplemented, "method GetUpdates not implemented")
}
func (UnimplementedHypervisorServer) ChangeVmTags(context.Context, *ChangeVmTagsRequest) (*ChangeVmTagsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ChangeVmTags not implemented")
}
func (UnimplementedHypervisorServer) ChangeVmOwnerUsers(context.Context, *ChangeVmOwnerUsersRequest) (*ChangeVmOwnerUsersResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ChangeVmOwnerUsers not implemented")
}
func (UnimplementedHypervisorServer) ChangeVmSize(context.Context, *ChangeVmSizeRequest) (*ChangeVmSizeResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ChangeVmSize not implemented")
}
func (UnimplementedHypervisorServer) GetCapacity(context.Context, *GetCapacityRequest) (*GetCapacityResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetCapacity not implemented")
}
func (UnimplementedHypervisorServer) testEmbeddedByValue() {}

// UnsafeHypervisorServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to HypervisorServer will
// result in compilation errors.
type UnsafeHypervisorServer interface {
	mustEmbedUnimplementedHypervisorServer()
}

func RegisterHypervisorServer(s grpc.ServiceRegistrar, srv HypervisorServer) {
	// If the following call panics, it indicates UnimplementedHypervisorServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Hypervisor_ServiceDesc, srv)
}

func _Hypervisor_GetVmInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetVmInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HypervisorServer).GetVmInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Hypervisor_GetVmInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HypervisorServer).GetVmInfo(ctx, req.(*GetVmInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Hypervisor_GetVmInfos_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetVmInfosRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HypervisorServer).GetVmInfos(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Hypervisor_GetVmInfos_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HypervisorServer).GetVmInfos(ctx, req.(*GetVmInfosRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Hypervisor_ListVMs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListVMsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HypervisorServer).ListVMs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Hypervisor_ListVMs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HypervisorServer).ListVMs(ctx, req.(*ListVMsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Hypervisor_CreateVm_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(HypervisorServer).CreateVm(&grpc.GenericServerStream[CreateVmRequest, CreateVmResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Hypervisor_CreateVmServer = grpc.BidiStreamingServer[CreateVmRequest, CreateVmResponse]

func _Hypervisor_CreateVmAsync_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateVmAsyncRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HypervisorServer).CreateVmAsync(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Hypervisor_CreateVmAsync_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HypervisorServer).CreateVmAsync(ctx, req.(*CreateVmAsyncRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Hypervisor_StartVm_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartVmRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HypervisorServer).StartVm(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Hypervisor_StartVm_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HypervisorServer).StartVm(ctx, req.(*StartVmRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Hypervisor_StartVmAsync_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartVmAsyncRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HypervisorServer).StartVmAsync(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Hypervisor_StartVmAsync_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HypervisorServer).StartVmAsync(ctx, req.(*StartVmAsyncRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Hypervisor_StopVm_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StopVmRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HypervisorServer).StopVm(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Hypervisor_StopVm_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HypervisorServer).StopVm(ctx, req.(*StopVmRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Hypervisor_RebootVm_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RebootVmRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HypervisorServer).RebootVm(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Hypervisor_RebootVm_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HypervisorServer).RebootVm(ctx, req.(*RebootVmRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Hypervisor_DestroyVm_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DestroyVmRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HypervisorServer).DestroyVm(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Hypervisor_DestroyVm_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HypervisorServer).DestroyVm(ctx, req.(*DestroyVmRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Hypervisor_DestroyVmAsync_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DestroyVmAsyncRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HypervisorServer).DestroyVmAsync(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Hypervisor_DestroyVmAsync_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HypervisorServer).DestroyVmAsync(ctx, req.(*DestroyVmAsyncRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Hypervisor_ListSubnets_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListSubnetsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HypervisorServer).ListSubnets(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Hypervisor_ListSubnets_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HypervisorServer).ListSubnets(ctx, req.(*ListSubnetsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Hypervisor_GetUpdates_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetUpdatesRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(HypervisorServer).GetUpdates(m, &grpc.GenericServerStream[GetUpdatesRequest, Update]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type Hypervisor_GetUpdatesServer = grpc.ServerStreamingServer[Update]

func _Hypervisor_ChangeVmTags_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChangeVmTagsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HypervisorServer).ChangeVmTags(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Hypervisor_ChangeVmTags_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HypervisorServer).ChangeVmTags(ctx, req.(*ChangeVmTagsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Hypervisor_ChangeVmOwnerUsers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChangeVmOwnerUsersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HypervisorServer).ChangeVmOwnerUsers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Hypervisor_ChangeVmOwnerUsers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HypervisorServer).ChangeVmOwnerUsers(ctx, req.(*ChangeVmOwnerUsersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Hypervisor_ChangeVmSize_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChangeVmSizeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HypervisorServer).ChangeVmSize(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Hypervisor_ChangeVmSize_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HypervisorServer).ChangeVmSize(ctx, req.(*ChangeVmSizeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Hypervisor_GetCapacity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCapacityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HypervisorServer).GetCapacity(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Hypervisor_GetCapacity_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HypervisorServer).GetCapacity(ctx, req.(*GetCapacityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Hypervisor_ServiceDesc is the grpc.ServiceDesc for Hypervisor service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Hypervisor_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "hypervisor.Hypervisor",
	HandlerType: (*HypervisorServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetVmInfo",
			Handler:    _Hypervisor_GetVmInfo_Handler,
		},
		{
			MethodName: "GetVmInfos",
			Handler:    _Hypervisor_GetVmInfos_Handler,
		},
		{
			MethodName: "ListVMs",
			Handler:    _Hypervisor_ListVMs_Handler,
		},
		{
			MethodName: "CreateVmAsync",
			Handler:    _Hypervisor_CreateVmAsync_Handler,
		},
		{
			MethodName: "StartVm",
			Handler:    _Hypervisor_StartVm_Handler,
		},
		{
			MethodName: "StartVmAsync",
			Handler:    _Hypervisor_StartVmAsync_Handler,
		},
		{
			MethodName: "StopVm",
			Handler:    _Hypervisor_StopVm_Handler,
		},
		{
			MethodName: "RebootVm",
			Handler:    _Hypervisor_RebootVm_Handler,
		},
		{
			MethodName: "DestroyVm",
			Handler:    _Hypervisor_DestroyVm_Handler,
		},
		{
			MethodName: "DestroyVmAsync",
			Handler:    _Hypervisor_DestroyVmAsync_Handler,
		},
		{
			MethodName: "ListSubnets",
			Handler:    _Hypervisor_ListSubnets_Handler,
		},
		{
			MethodName: "ChangeVmTags",
			Handler:    _Hypervisor_ChangeVmTags_Handler,
		},
		{
			MethodName: "ChangeVmOwnerUsers",
			Handler:    _Hypervisor_ChangeVmOwnerUsers_Handler,
		},
		{
			MethodName: "ChangeVmSize",
			Handler:    _Hypervisor_ChangeVmSize_Handler,
		},
		{
			MethodName: "GetCapacity",
			Handler:    _Hypervisor_GetCapacity_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "CreateVm",
			Handler:       _Hypervisor_CreateVm_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "GetUpdates",
			Handler:       _Hypervisor_GetUpdates_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "hypervisor/grpc/hypervisor.proto",
}
